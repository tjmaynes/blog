<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><docs>https://blogs.law.harvard.edu/tech/rss</docs><title>kotlin on TJ Maynes</title><link>/categories/kotlin/</link><description>Recent content in kotlin on TJ Maynes</description><image><title>kotlin on TJ Maynes</title><link>/categories/kotlin/</link><url>https://source.unsplash.com/collection/983219/2000x1322</url></image><ttl>1440</ttl><generator>Hugo 0.83.1</generator><language>en-us</language><lastBuildDate>Sun, 13 Jun 2021 17:59:12 UT</lastBuildDate><atom:link href="/categories/kotlin/index.xml" rel="self" type="application/rss+xml"/><item><title>My Monad Analogy</title><link>/post/my-monad-analogy/</link><pubDate>Tue, 29 Oct 2019 11:00:00 UT</pubDate><dc:creator>TJ Maynes</dc:creator><guid>/post/my-monad-analogy/</guid><description>I&amp;rsquo;ve been using the Either and Option monads on various projects (in different runtimes) over the last couple of years. I like utilizing these monads as a way of handle errors from external systems. However, when it comes time to introducing someone new to these monads, I&amp;rsquo;m unable to describe what makes a monad a monad. However, after doing some research I found an analogy that encapsulates what I believe to be the spirit of what makes a monad a monad.</description><category domain="/categories/functional-programming">Functional-Programming</category><category domain="/categories/kotlin">Kotlin</category><content:encoded><![CDATA[I&amp;rsquo;ve been using the Either and Option monads on various projects (in different runtimes) over the last couple of years. I like utilizing these monads as a way of handle errors from external systems. However, when it comes time to introducing someone new to these monads, I&amp;rsquo;m unable to describe what makes a monad a monad. However, after doing some research I found an analogy that encapsulates what I believe to be the spirit of what makes a monad a monad.
 A monad is an abstract data type that enables programmers to chain complex, nondeterministic operations in a readable way.
 An abstract data type (ADT) is a kind of data type defined by it&amp;rsquo;s behavior from the point of view from a user. Since an ADT is created from the user&amp;rsquo;s point of view, it&amp;rsquo;s internal presentation is hidden, thus enabling us to focus more on behavior than caring what data is being held (it could be a String, Integer, YourCustomObject, etc).
The ability to chain operations is the functor attribute of monads. In category theory, a functor is a something has enables mappable behavior, such as iterating over a list of objects/strings/etc. To enable the chaining of nondeterministic operations, two functions are found on monadic types: return and bind.
The return function places a value into a monadic context, whereas the bind function applies a function in a monadic context.
 Note: Depending on the programming language or library that you are using, the return function will typically be represented through the /constructor/ method and bind may have a different name such as flatMap or map.
 Let&amp;rsquo;s write an example of monads in action using Kotlin and a functional programming library called ArrowKt. A quick real-world example is when I&amp;rsquo;m trying to eat a donut from my favorite donut place in the Upper West Side, Daily Provisions.
Let&amp;rsquo;s write a function that encapsulates the operation of getting a donut from Daily Provisions and, for simplicity, we&amp;rsquo;ll choose the Option monad as its return type.
fun getDonut(time: Date): Option&amp;lt;Donut&amp;gt; = if (donutsAreAvailable(time)) { Some(Donut()) } else { None } The above function could return either my donut or nothing depending on some external factor (time). When we pass a value into the Some function, we are effectively using the return trait of a monadic type. The None function is a type of Option that returns&amp;hellip;nothing! Next, do something with&amp;hellip;something.
val eatADonut = getDonut(timeBefore11am) .map { donut -&amp;gt; donut.eat() } The above variable gets a donut and if a donut is found it will map, or bind, to a function that eats the donut. If the getDonut returns a None, because I overslept and missed the opportunity to get a donut, then our map method will never get called.
]]></content:encoded></item></channel></rss>